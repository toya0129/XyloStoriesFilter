/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * filter.c
 *
 * Code generation for function 'filter'
 *
 */

/* Include files */
#include "XyloStoriesFilter.h"
#include "filter.h"
#include "XyloStoriesFilter_emxutil.h"

/* Function Definitions */
void b_filter(const emxArray_real_T *x, emxArray_real_T *y)
{
  unsigned int x_idx_0;
  int i2;
  int nx;
  int nx_m_nb;
  int k;
  int j;
  int naxpy;
  static const double dv6[49] = { -0.00152818336754993, -0.0023302418294280595,
    0.0017137251272618739, 0.0043060407174671921, -0.0019426608660129885,
    -0.0081910730057441032, 0.00138464468008337, 0.014260455330128497,
    0.0011333555395626569, -0.02209516099852564, -0.0067604990260463011,
    0.030508245626736871, 0.016182694559438996, -0.037724477090114845,
    -0.029254141724035922, 0.041785992872610818, 0.044833343344691072,
    -0.04107799973851773, -0.060900905040619457, 0.034820318527319927,
    0.074950832042514223, -0.023370502475087068, -0.084559403085327875,
    0.0082343953124078256, 0.0879750128802822, 0.0082343953124078256,
    -0.084559403085327875, -0.023370502475087068, 0.074950832042514223,
    0.034820318527319927, -0.060900905040619457, -0.04107799973851773,
    0.044833343344691072, 0.041785992872610818, -0.029254141724035922,
    -0.037724477090114845, 0.016182694559438996, 0.030508245626736871,
    -0.0067604990260463011, -0.02209516099852564, 0.0011333555395626569,
    0.014260455330128497, 0.00138464468008337, -0.0081910730057441032,
    -0.0019426608660129885, 0.0043060407174671921, 0.0017137251272618739,
    -0.0023302418294280595, -0.00152818336754993 };

  x_idx_0 = (unsigned int)x->size[0];
  i2 = y->size[0];
  y->size[0] = (int)x_idx_0;
  emxEnsureCapacity_real_T(y, i2);
  nx = x->size[0];
  nx_m_nb = y->size[0];
  i2 = y->size[0];
  y->size[0] = nx_m_nb;
  emxEnsureCapacity_real_T(y, i2);
  for (i2 = 0; i2 < nx_m_nb; i2++) {
    y->data[i2] = 0.0;
  }

  if (x->size[0] >= 98) {
    for (k = 0; k < 49; k++) {
      nx_m_nb = k + 1;
      for (j = nx_m_nb; j <= nx; j++) {
        y->data[j - 1] += dv6[k] * x->data[(j - k) - 1];
      }
    }
  } else {
    if (x->size[0] > 49) {
      nx_m_nb = x->size[0] - 50;
    } else {
      nx_m_nb = -1;
    }

    for (k = 0; k <= nx_m_nb; k++) {
      for (j = 0; j < 49; j++) {
        i2 = k + j;
        y->data[i2] += x->data[k] * dv6[j];
      }
    }

    naxpy = x->size[0] - nx_m_nb;
    i2 = nx_m_nb + 2;
    for (k = i2; k <= nx; k++) {
      for (j = 0; j <= naxpy - 2; j++) {
        nx_m_nb = (k + j) - 1;
        y->data[nx_m_nb] += x->data[k - 1] * dv6[j];
      }

      naxpy--;
    }
  }
}

void c_filter(const emxArray_real_T *x, emxArray_real_T *y)
{
  unsigned int x_idx_0;
  int i3;
  int nx;
  int nx_m_nb;
  int k;
  int j;
  int naxpy;
  static const double dv7[49] = { -0.0015778458543382085, 0.0053091335681012888,
    0.00099132288494504172, -0.0077257381155733046, 3.0053560953886332E-17,
    0.012135515993688223, -0.0023698338751486983, -0.018077739196814692,
    0.0069384953423412641, 0.024647152583588235, -0.014163636569087435,
    -0.030643285258483605, 0.023993494989405915, 0.034792035150562291,
    -0.035817269410062441, -0.035996366212890693, 0.048527850415965718,
    0.033565191421366034, -0.060688874560477918, -0.027372458079925222,
    0.070775899528075115, 0.01791171011199845, -0.077445236804295672,
    -0.0062323106115006162, 0.079777242134122878, -0.0062323106115006162,
    -0.077445236804295672, 0.01791171011199845, 0.070775899528075115,
    -0.027372458079925222, -0.060688874560477918, 0.033565191421366034,
    0.048527850415965718, -0.035996366212890693, -0.035817269410062441,
    0.034792035150562291, 0.023993494989405915, -0.030643285258483605,
    -0.014163636569087435, 0.024647152583588235, 0.0069384953423412641,
    -0.018077739196814692, -0.0023698338751486983, 0.012135515993688223,
    3.0053560953886332E-17, -0.0077257381155733046, 0.00099132288494504172,
    0.0053091335681012888, -0.0015778458543382085 };

  x_idx_0 = (unsigned int)x->size[0];
  i3 = y->size[0];
  y->size[0] = (int)x_idx_0;
  emxEnsureCapacity_real_T(y, i3);
  nx = x->size[0];
  nx_m_nb = y->size[0];
  i3 = y->size[0];
  y->size[0] = nx_m_nb;
  emxEnsureCapacity_real_T(y, i3);
  for (i3 = 0; i3 < nx_m_nb; i3++) {
    y->data[i3] = 0.0;
  }

  if (x->size[0] >= 98) {
    for (k = 0; k < 49; k++) {
      nx_m_nb = k + 1;
      for (j = nx_m_nb; j <= nx; j++) {
        y->data[j - 1] += dv7[k] * x->data[(j - k) - 1];
      }
    }
  } else {
    if (x->size[0] > 49) {
      nx_m_nb = x->size[0] - 50;
    } else {
      nx_m_nb = -1;
    }

    for (k = 0; k <= nx_m_nb; k++) {
      for (j = 0; j < 49; j++) {
        i3 = k + j;
        y->data[i3] += x->data[k] * dv7[j];
      }
    }

    naxpy = x->size[0] - nx_m_nb;
    i3 = nx_m_nb + 2;
    for (k = i3; k <= nx; k++) {
      for (j = 0; j <= naxpy - 2; j++) {
        nx_m_nb = (k + j) - 1;
        y->data[nx_m_nb] += x->data[k - 1] * dv7[j];
      }

      naxpy--;
    }
  }
}

void filter(const emxArray_real_T *x, emxArray_real_T *y)
{
  unsigned int x_idx_0;
  int i1;
  int nx;
  int nx_m_nb;
  int k;
  int j;
  int naxpy;
  static const double dv5[49] = { 0.0049679352140034232, -0.0013079855171886177,
    -0.0068735340613908617, -0.0028250940455763016, 0.0083663135617343832,
    0.010166648053432096, -0.0058462708174721956, -0.019254534093837747,
    -0.0043454098597987458, 0.024385657561791271, 0.021773141457284935,
    -0.018543979327538603, -0.03986409692104359, -0.0014420123028182831,
    0.048122615821187043, 0.030997037121725621, -0.037907486162757749,
    -0.058269044785412429, 0.0084145364746303544, 0.069477004244358528,
    0.03110308022190128, -0.056414455746156611, -0.064826392648530809,
    0.021686727831943507, 0.078052638758387971, 0.021686727831943507,
    -0.064826392648530809, -0.056414455746156611, 0.03110308022190128,
    0.069477004244358528, 0.0084145364746303544, -0.058269044785412429,
    -0.037907486162757749, 0.030997037121725621, 0.048122615821187043,
    -0.0014420123028182831, -0.03986409692104359, -0.018543979327538603,
    0.021773141457284935, 0.024385657561791271, -0.0043454098597987458,
    -0.019254534093837747, -0.0058462708174721956, 0.010166648053432096,
    0.0083663135617343832, -0.0028250940455763016, -0.0068735340613908617,
    -0.0013079855171886177, 0.0049679352140034232 };

  x_idx_0 = (unsigned int)x->size[0];
  i1 = y->size[0];
  y->size[0] = (int)x_idx_0;
  emxEnsureCapacity_real_T(y, i1);
  nx = x->size[0];
  nx_m_nb = y->size[0];
  i1 = y->size[0];
  y->size[0] = nx_m_nb;
  emxEnsureCapacity_real_T(y, i1);
  for (i1 = 0; i1 < nx_m_nb; i1++) {
    y->data[i1] = 0.0;
  }

  if (x->size[0] >= 98) {
    for (k = 0; k < 49; k++) {
      nx_m_nb = k + 1;
      for (j = nx_m_nb; j <= nx; j++) {
        y->data[j - 1] += dv5[k] * x->data[(j - k) - 1];
      }
    }
  } else {
    if (x->size[0] > 49) {
      nx_m_nb = x->size[0] - 50;
    } else {
      nx_m_nb = -1;
    }

    for (k = 0; k <= nx_m_nb; k++) {
      for (j = 0; j < 49; j++) {
        i1 = k + j;
        y->data[i1] += x->data[k] * dv5[j];
      }
    }

    naxpy = x->size[0] - nx_m_nb;
    i1 = nx_m_nb + 2;
    for (k = i1; k <= nx; k++) {
      for (j = 0; j <= naxpy - 2; j++) {
        nx_m_nb = (k + j) - 1;
        y->data[nx_m_nb] += x->data[k - 1] * dv5[j];
      }

      naxpy--;
    }
  }
}

/* End of code generation (filter.c) */
